# ENAHOデータの外れ値検出・除去手順

## 概要

複雑調査設計（ENAHO）における食品群消費量データに対し、調査重みを考慮したIQR法による外れ値検出・除去を実施。品目ごとに独立した処理を行い、ある品目の外れ値が他品目のデータに影響しない構造を実現。

------------------------------------------------------------------------

## 初期の課題

### 問題1: svyby + svyquantile のエラー

**エラー内容:**

```         
Error in h(simpleError(msg, call)) : 
  error in evaluating the argument 'x' in selecting a method for function 't': 
  missing value where TRUE/FALSE needed
```

**原因:** - グループ（area × inc_quintile）の一部で全データがNAまたはデータ不足 - `svyquantile`が空データに対しNAを返し、IQR計算時にNA判定でエラー - surveyパッケージのバージョンやデータ構造の問題

### 問題2: svybyの内部エラー

**エラー内容:**

```         
svyby error: length of 'dimnames' [1] not equal to array extent
```

**原因:** - `svyby` + `svyquantile`の組み合わせが不安定 - 内部的な配列処理でdimnames設定に失敗

------------------------------------------------------------------------

## 解決アプローチの変遷

### アプローチ1: tryCatchによるエラー処理（失敗）

``` r
detect_outliers_survey <- function(design, var_name, by_vars = c("area", "inc_quintile")) {
  quantiles <- tryCatch({
    svyby(
      formula = as.formula(paste("~", var_name)),
      by = as.formula(paste("~", paste(by_vars, collapse = " + "))),
      design = design,
      FUN = svyquantile,
      quantiles = c(0.25, 0.5, 0.75),
      na.rm = TRUE
    )
  }, error = function(e) {
    cat("svyby error for", var_name, ":", e$message, "\n")
    return(NULL)
  })
  
  if(is.null(quantiles)) {
    return(data.frame(is_outlier = rep(FALSE, nrow(model.frame(design)))))
  }
  
  # ... IQR計算とフェンス設定
}
```

**結果:** エラーは捕捉できたが、全変数で外れ値が0件（検出失敗）

### アプローチ2: 非重み付きIQR法（成功したが不完全）

``` r
detect_outliers_unweighted <- function(design, var_name, by_vars = c("area", "inc_quintile")) {
  df_data <- model.frame(design)
  df_data$is_outlier <- FALSE
  
  result <- df_data %>%
    group_by(across(all_of(by_vars))) %>%
    mutate(
      q25 = quantile(.data[[var_name]], 0.25, na.rm = TRUE),
      q75 = quantile(.data[[var_name]], 0.75, na.rm = TRUE),
      IQR = q75 - q25,
      lower_fence = q25 - 1.5 * IQR,
      upper_fence = q75 + 1.5 * IQR,
      is_outlier = !is.na(.data[[var_name]]) & 
                   (.data[[var_name]] < lower_fence | .data[[var_name]] > upper_fence)
    ) %>%
    ungroup() %>%
    select(-q25, -q75, -IQR, -lower_fence, -upper_fence)
  
  return(as.data.frame(result))
}
```

**結果:** 外れ値検出は成功したが、調査重みを考慮していない

------------------------------------------------------------------------

## 最終解決策: 重み付き外れ値検出（手動グループ処理）

### 重要な設計方針

1.  **品目ごとに独立処理**: ある品目の外れ値が他品目データを削除しない
2.  **調査重みを考慮**: `Hmisc::wtd.quantile`で重み付き分位数を計算
3.  **グループ単位処理**: area × inc_quintile の各セルで独立してIQR法を適用

### 実装コード

``` r
library(survey)
library(dplyr)
library(Hmisc)  # wtd.quantile用

# 重み付き外れ値検出関数（手動グループ処理版）
detect_outliers_weighted_manual <- function(design, var_name, by_vars = c("area", "inc_quintile")) {
  
  # データと重みを取得
  df_data <- model.frame(design)
  weights_vec <- weights(design, "sampling")
  df_data$survey_weight <- weights_vec
  
  # 外れ値フラグ列を初期化
  outlier_col <- paste0(var_name, "_is_outlier")
  df_data[[outlier_col]] <- FALSE
  
  # グループごとに処理
  groups <- df_data %>%
    select(all_of(by_vars)) %>%
    distinct()
  
  for(i in 1:nrow(groups)) {
    # グループフィルタ作成
    group_filter <- rep(TRUE, nrow(df_data))
    for(var in by_vars) {
      group_filter <- group_filter & (df_data[[var]] == groups[[var]][i])
    }
    
    # グループデータ抽出
    group_data <- df_data[group_filter, ]
    group_values <- group_data[[var_name]]
    group_weights <- group_data$survey_weight
    
    # 有効データのみ
    valid_idx <- !is.na(group_values)
    if(sum(valid_idx) < 5) next  # データ不足はスキップ
    
    valid_values <- group_values[valid_idx]
    valid_weights <- group_weights[valid_idx]
    
    # 重み付き分位数計算
    tryCatch({
      q25 <- wtd.quantile(valid_values, weights = valid_weights, probs = 0.25)
      q75 <- wtd.quantile(valid_values, weights = valid_weights, probs = 0.75)
      
      IQR <- q75 - q25
      lower_fence <- q25 - 1.5 * IQR
      upper_fence <- q75 + 1.5 * IQR
      
      # 外れ値フラグ設定
      outlier_idx <- which(group_filter & !is.na(df_data[[var_name]]) & 
                           (df_data[[var_name]] < lower_fence | df_data[[var_name]] > upper_fence))
      
      if(length(outlier_idx) > 0) {
        df_data[[outlier_col]][outlier_idx] <- TRUE
      }
      
    }, error = function(e) {
      cat("Error processing group for", var_name, ":", e$message, "\n")
    })
  }
  
  return(df_data)
}
```

### 実行フロー

``` r
# 全変数について外れ値検出（品目ごと独立）
clean_data <- model.frame(enaho_design)
outlier_summary_list <- list()

for(var in myVar) {
  cat("外れ値検出中:", var, "\n")
  
  # 外れ値検出結果を取得
  result <- detect_outliers_weighted_manual(enaho_design, var)
  
  # 外れ値フラグの列名
  outlier_col <- paste0(var, "_is_outlier")
  
  # 外れ値統計
  n_outliers <- sum(result[[outlier_col]], na.rm = TRUE)
  n_total <- sum(!is.na(clean_data[[var]]))
  outlier_rate <- ifelse(n_total > 0, (n_outliers / n_total) * 100, 0)
  
  outlier_summary_list[[var]] <- data.frame(
    variable = var,
    total_obs = n_total,
    outliers = n_outliers,
    outlier_rate = outlier_rate
  )
  
  # 外れ値をNAに置換（品目ごと独立）
  clean_data[[var]][result[[outlier_col]]] <- NA
  
  # 外れ値フラグも保存（必要に応じて）
  clean_data[[outlier_col]] <- result[[outlier_col]]
  
  cat("  外れ値数:", n_outliers, "/", n_total, "(", round(outlier_rate, 2), "%)\n")
}

# 外れ値統計サマリー
outlier_summary <- bind_rows(outlier_summary_list)
print(outlier_summary)

# 外れ値除去前後の比較
before_after <- data.frame(
  variable = myVar,
  before_na = sapply(myVar, function(v) sum(is.na(model.frame(enaho_design)[[v]]))),
  after_na = sapply(myVar, function(v) sum(is.na(clean_data[[v]]))),
  outliers_removed = sapply(myVar, function(v) {
    sum(is.na(clean_data[[v]])) - sum(is.na(model.frame(enaho_design)[[v]]))
  })
)
print(before_after)

# 外れ値フラグ列を除去（オプション）
outlier_flag_cols <- grep("_is_outlier$", names(clean_data), value = TRUE)
clean_data_final <- clean_data[, !(names(clean_data) %in% outlier_flag_cols)]

# 外れ値除去後の調査設計オブジェクト作成
enaho_design_clean <- svydesign(
  id = ~ CONGLOME,
  strata = ~ ESTRATO,
  weights = ~ FACTOR07,
  data = clean_data_final,
  nest = TRUE
)

cat("\n外れ値除去完了！clean_data_finalとenaho_design_cleanが作成されました。\n")
```

------------------------------------------------------------------------

## 実行結果

```         
外れ値検出中: staple 
  外れ値数: 1294 / 11808 ( 10.96 %)
外れ値検出中: vegetable 
  外れ値数: 746 / 6968 ( 10.71 %)
外れ値検出中: fruit 
  外れ値数: 640 / 6565 ( 9.75 %)
外れ値検出中: legume 
  外れ値数: 696 / 6477 ( 10.75 %)
外れ値検出中: ASF 
  外れ値数: 925 / 9075 ( 10.19 %)
外れ値検出中: dairy 
  外れ値数: 587 / 5518 ( 10.64 %)
外れ値検出中: oilfat 
  外れ値数: 176 / 1991 ( 8.84 %)
外れ値検出中: other 
  外れ値数: 1362 / 11319 ( 12.03 %)
```

### 結果の解釈

-   **除去率**: 各品目で約8.84%〜12.03%の外れ値を検出
-   **IQR法の妥当性**: 1.5×IQR基準による外れ値除去率として妥当な範囲
-   **品目間の差異**:
    -   oilfat（油脂）: 8.84% → 消費パターンが比較的安定
    -   other（その他食品）: 12.03% → 多様性が高く外れ値が多い

------------------------------------------------------------------------

## 重要なポイント

### 1. 品目ごとの独立処理

各品目の外れ値除去は独立して実行されるため、ある品目の外れ値が他の品目のデータを削除しない設計。これは「品目ごとの平均消費量」を算出する分析目的に適合。

### 2. 調査重みの重要性

-   ENAHOはクラスタ抽出・階層化サンプリング設計
-   重みを無視すると地域・所得階層の推定にバイアスが生じる
-   `wtd.quantile`により調査重みを考慮した分位数計算を実現

### 3. エラー処理の堅牢性

-   グループごとにtryCatchでエラーをキャッチ
-   データ不足グループ（n \< 5）はスキップ
-   全体の処理を止めずに継続

------------------------------------------------------------------------

## 次のステップ

### 外れ値除去効果の確認

``` r
# 外れ値除去前後のボックスプロット比較
for(var in myVar) {
  par(mfrow = c(1, 2))
  boxplot(model.frame(enaho_design)[[var]], main = paste(var, "- Before"))
  boxplot(clean_data_final[[var]], main = paste(var, "- After"))
}
```

### 外れ値除去後の基本統計

``` r
# 地域×所得階層別の平均（外れ値除去後）
area_inc_means_clean <- svyby(
  formula = as.formula(paste("~", paste(myVar, collapse = " + "))),
  by = ~ area + inc_quintile,
  design = enaho_design_clean,
  FUN = svymean,
  na.rm = TRUE,
  keep.var = TRUE
)
```

------------------------------------------------------------------------

## まとめ

**完成した分析フロー:**

1.  ✅ svydesign作成（複雑調査設計考慮）
2.  ✅ 所得5分位の計算と追加
3.  ✅ 地域×所得階層別の基本統計（平均・分散・NA数）
4.  ✅ ボックスプロット可視化（log1p変換）
5.  ✅ 調査重み付き外れ値検出・除去（品目ごと独立）
6.  ✅ 外れ値除去後のclean_data_final作成

これにより、ペルーENAHOデータの食品群消費量について、**統計的に堅牢な地域×所得格差分析の基盤**が確立された。
